---
layout: post
title: js基础——执行上下文
description: >
 存储着函数执行时所依赖的数据，也就是上下文中所定义的变量数据，但是这个对象是可以被访问到的，也就是每次进入执行上下文时，都会创建或激活这个对象，这个时候我们就可以访问存放在这个对象中的函数标识符，形参，变量声明等数据，当EC出栈这个对象会被释放回收或者是静默，就无法访问这个对象了
author: author1
image: https://cdn.jsdelivr.net/gh/zouzenghu/cdn@7.18/assets/img/ecmascript/1_FA9NGxNB6-v1oI2qGEtlRQ_optimized.png
---
### JS执行上下文
### 执行上下文相关概念

#### EC：函数执行环境（或执行上下文），Execution Context

#### ECS：执行环境栈，Execution Context Stack(先进后出)

#### VO变量对象（Variable Object）

* JS的执行上下文中都有一个对象用来存放执行上下文中可被访问但是不能被delete的函数标识符，形参，变量声明等，它们会给挂在这个对象上，对象的属性对应它们的key象属性的值对应value但这个对象规范上或者说是引擎实现上的不可再JS环境中访问的活动对象

#### AO活动对象（Activation Object）

* 也存储着函数执行时所依赖的数据，也就是上下文中所定义的变量数据，但是这个对象是可以被访问到的，也就是每次进入执行上下文时，都会创建或激活这个对象，这个时候我们就可以访问存放在这个对象中的函数标识符，形参，变量声明等数据，当EC出栈这个对象会被释放回收或者是静默，就无法访问这个对象了

#### 执行上下文栈

* JavaScript执行在单线程上，所有的代码都是排队执行

* 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部

* 每当进入一个函数的执行就会创建函数的执行上下文并且把它压入执行栈的顶部，当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收

* 浏览器的js执行引擎总是访问栈顶的执行上下文

* 全局上下文只有唯一的一个，他在浏览器关闭时出栈

#### 函数执行上下文

1. 进入脚本创建全局EC（执行上下文）压入ECS栈顶

2. 主线程执行到函数处
   
   1. 创建任务函数的EC
   
   2. 将任务函数EC压入栈顶
   
   3. 执行EC创建AO活动作用域对象（如果是异步则退出主线程挂起该异步任务）
   
   4. 执行完EC，出栈并等待被销毁，AO活动作用域对象被销毁
   
   5. 开始执行下一任务函数

#### 函数执行上下文内生命周期

* 函数生命周期：创建——》执行——》销毁

* 创建阶段
  
  1. 创建作用域链（Scope Chain）
  
  2. 创建活动作用域对象（AO）首先初始化函数的参数arguments，初始化函数声明，初始化变量（undefined），函数的优先级要高于变量，如果变量和函重名，变量则会被忽略（这就是为什么会发生声明提前这种情况）
     
     1. 创建arguments对象，检查上下文，初始化参数名和值并创建引用复制（这就是为什么函数可以在声明之前调用执行）
     
     2. 扫描上下文的函数声明（而非函数表达式）
        
        1. 为发现的每一个函数，在AO上创建一个属性key，value为指向函数在内存中的引用
        
        2. 如果函数的声明已经存在，引用指针将被重写
     
     3. 扫名上下文中的变量声明
        
        1. 为发现的每个变量声明，在AO上创建一个属性key，value为初始化值undefined
        
        2. 如果变量名已经存在在AO上，将不会进行任何操作并继续扫描
     
     4. 求出上下文内部'this'的值

* 执行阶段
  
  1. 变量开始赋值，形参变实参，代码执行

* 回收阶段
  
  1. 执行上下文出栈等待垃圾回收回收执行上下文
